import numpy as np

"""
Before using these functions, please normalize the signal between 0 and 1.
"""

def SatABPmax(Signal,SliceStart,SliceEnd):
    """
    Return the signal generated by the 'Saturation to ABP maximum' type of artifact in the interval from SliceStart to SliceEnd.

    Parameters
    ----------
    Signal : 1-D numpy array (normalized)
    SliceStart : int
    SliceEnd : int

    Returns
    -------
    SatABPmaxSet : 1-D numpy array (normalized)
    """
    if len(Signal) == 0:
        raise ValueError("Empty Signal.")
    if SliceStart > len(Signal) or SliceEnd > len(Signal):
        raise ValueError("Start or end index out of range.")
    if SliceStart > SliceEnd:
        raise ValueError("Start index exceeds end index.")
    if SliceEnd - SliceStart < 100:
        raise ValueError("The length of the interval is too short.")
    if type(SliceStart) != int or type(SliceEnd) != int:
        raise TypeError("The index must be an integer.")
    
    SatABPmaxSet = Signal.copy()
    
    interval = SliceEnd - SliceStart

    MinDias = np.min(SatABPmaxSet)
    MaxSyst = np.max(SatABPmaxSet)

    VecToSat = np.arange(interval)

    TmpMax = np.random.uniform(low=MaxSyst, high=1.0)
    VecToSat = np.tanh((np.pi * VecToSat * np.random.uniform(low=0.1, high=0.9)) / (0.2*interval)) * (TmpMax - SatABPmaxSet[SliceStart]) + SatABPmaxSet[SliceStart]

    t = np.linspace(0,15*interval/500,interval)
    exp_t = np.exp(-t)

    SatABPmaxSet[SliceStart:SliceEnd] = (exp_t*SatABPmaxSet[SliceStart:SliceEnd] + (1-exp_t)*VecToSat) + np.random.normal(loc=0, scale=0.001, size=(interval,))

    return SatABPmaxSet

def SatABPmin(Signal,SliceStart,SliceEnd):
    """
    Return the signal generated by the 'Saturation to ABP minimum' type of artifact in the interval from SliceStart to SliceEnd.

    Parameters
    ----------
    Signal : 1-D numpy array (normalized)
    SliceStart : int
    SliceEnd : int

    Returns
    -------
    SatABPmaxSet : 1-D numpy array (normalized)
    """
    if len(Signal) == 0:
        raise ValueError("Empty Signal.")
    if SliceStart > len(Signal) or SliceEnd > len(Signal):
        raise ValueError("Start or end index out of range.")
    if SliceStart > SliceEnd:
        raise ValueError("Start index exceeds end index.")
    if SliceEnd - SliceStart < 100:
        raise ValueError("The length of the interval is too short.")
    if type(SliceStart) != int or type(SliceEnd) != int:
        raise TypeError("The index must be an integer.")

    SatABPminSet = Signal.copy()
    
    interval = SliceEnd - SliceStart
    if interval <= 1000:
        tmp = 100
    else:
        tmp = 200

    MinDias = np.random.uniform(low=0.01, high=np.min(SatABPminSet))
    MeanSyst = np.mean(SatABPminSet)

    LeftSize= int(interval * 0.8)
    RightSize = interval - LeftSize


    LeftVecToSat = np.arange(LeftSize)
    RightVecToSat = np.arange(RightSize)

    LeftVecToSat = (1 - np.tanh((np.pi * LeftVecToSat * np.random.uniform(low=0.1, high=0.3)) / tmp)) * (MeanSyst * np.random.normal(loc=1.05, scale=0.05) - MinDias) + MinDias
    RightVecToSat = (np.tanh((np.pi * (RightVecToSat - RightSize) * np.random.uniform(low=0.7, high=0.99)) / tmp) + 1) * (MeanSyst * np.random.normal(loc=0.95, scale=0.05) - MinDias) + np.min(LeftVecToSat)
    VecToSat = np.concatenate([LeftVecToSat, RightVecToSat])

    t = np.linspace(0,20,interval)
    exp_t = np.exp(-t)

    SatABPminSet[SliceStart:SliceEnd] = (exp_t*SatABPminSet[SliceStart:SliceEnd] + (1-exp_t)*VecToSat) + +np.random.normal(loc=0, scale=0.001, size=(interval,))

    return SatABPminSet

def RPP(Signal,SliceStart,SliceEnd):
    """
    Return the signal generated by the 'Reduced pulse pressure' type of artifact in the interval from SliceStart to SliceEnd.

    Parameters
    ----------
    Signal : 1-D numpy array (normalized)
    SliceStart : int
    SliceEnd : int

    Returns
    -------
    SatABPmaxSet : 1-D numpy array (normalized)
    """
    if len(Signal) == 0:
        raise ValueError("Empty Signal.")
    if SliceStart > len(Signal) or SliceEnd > len(Signal):
        raise ValueError("Start or end index out of range.")
    if SliceStart > SliceEnd:
        raise ValueError("Start index exceeds end index.")
    if SliceEnd - SliceStart < 100:
        raise ValueError("The length of the interval is too short.")
    if type(SliceStart) != int or type(SliceEnd) != int:
        raise TypeError("The index must be an integer.")

    RedABPSet = Signal.copy()
    
    interval = SliceEnd - SliceStart

    RedABP = RedABPSet[SliceStart:SliceEnd]

    InitDias = np.min(RedABP)
    SaledRedABP = (RedABP - InitDias) * np.linspace(np.random.uniform(0.8, 0.95), np.random.uniform(0.2, 0.5), len(RedABP)) + InitDias

    RedABPSet[SliceStart:SliceEnd] = SaledRedABP

    return RedABPSet 

def ImpNoise(Signal,SliceStart,SliceEnd):
    """
    Return the signal generated by the 'Impulse' type of artifact in the interval from SliceStart to SliceEnd.

    Parameters
    ----------
    Signal : 1-D numpy array (normalized)
    SliceStart : int
    SliceEnd : int

    Returns
    -------
    SatABPmaxSet : 1-D numpy array (normalized)
    """
    if len(Signal) == 0:
        raise ValueError("Empty Signal.")
    if SliceStart > len(Signal) or SliceEnd > len(Signal):
        raise ValueError("Start or end index out of range.")
    if SliceStart > SliceEnd:
        raise ValueError("Start index exceeds end index.")
    if SliceEnd - SliceStart < 100:
        raise ValueError("The length of the interval is too short.")
    if type(SliceStart) != int or type(SliceEnd) != int:
        raise TypeError("The index must be an integer.")
    
    ImpSet = Signal.copy()
    
    ImpSize = np.random.randint(2,6)

    SecSize = (SliceEnd-SliceStart) // ImpSize
    
    if (SliceEnd-SliceStart) % ImpSize != 0:
        SliceEnd = SliceEnd - (SliceEnd-SliceStart) % ImpSize
    fs = np.random.uniform(100, 200)

    VecToSat = np.arange(-(SecSize // 2), SecSize - (SecSize // 2)) + 0.01

    ImpulseArt = 0.05 * np.sin((np.pi * VecToSat[None]) / (fs * np.random.uniform(0.1, 0.3, ImpSize)[:,None])) / (np.pi * VecToSat[None] / fs)

    ImpulseArt = np.random.choice([-1,1], size=ImpSize, replace=True)[:,None] * ImpulseArt
    ImpulseArt = np.reshape(ImpulseArt, (SecSize * ImpSize)).copy()

    ImpSet[SliceStart:SliceEnd] += ImpulseArt
    ImpSet = np.clip(ImpSet, 0.01, 0.99)

    return ImpSet


def HFNoise(Signal,SliceStart,SliceEnd):
    """
    Return the signal generated by the 'High frequency' type of artifact in the interval from SliceStart to SliceEnd.

    Parameters
    ----------
    Signal : 1-D numpy array (normalized)
    SliceStart : int
    SliceEnd : int

    Returns
    -------
    SatABPmaxSet : 1-D numpy array (normalized)
    """
    if len(Signal) == 0:
        raise ValueError("Empty Signal.")
    if SliceStart > len(Signal) or SliceEnd > len(Signal):
        raise ValueError("Start or end index out of range.")
    if SliceStart > SliceEnd:
        raise ValueError("Start index exceeds end index.")
    if SliceEnd - SliceStart < 100:
        raise ValueError("The length of the interval is too short.")
    if type(SliceStart) != int or type(SliceEnd) != int:
        raise TypeError("The index must be an integer.")

    HFASet = Signal.copy()
    interval = SliceEnd - SliceStart

    HF_nb = np.random.randint(6) * 2
    HF_pt = np.sort(np.random.choice(interval, HF_nb)) + SliceStart
    HF_st = np.concatenate((np.array([SliceStart]),HF_pt[1::2]))
    HF_en = np.concatenate((HF_pt[::2],np.array([SliceEnd])))

    for i,j in zip(HF_st,HF_en):
        HFASet[i:j] += np.random.normal(0, 0.08, size=(j-i,))

    HFASet[SliceStart:SliceEnd] = np.clip(HFASet[SliceStart:SliceEnd], 0.0, 1.0)

    return HFASet